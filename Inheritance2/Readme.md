### El Constructor de una Clase Derivada Debe Llamar al Constructor de su Clase Base
Cada constructor de una clase derivada debe llamar implícita o explícitamente al constructor de su clase base para asegurar que las variables de instancia heredadas de la clase base se inicialicen correctamente.
El constructor de seis parámetros de `BasePlusCommissionEmployee` llama explícitamente al constructor de cinco parámetros de la clase `CommissionEmployee` para inicializar la porción de `CommissionEmployee` de un objeto `BasePlusCommissionEmployee`, es decir, el `FirstName`, `LastName`, `SocialSecurityNumber`, `GrossSales` y `CommissionRate`.
Las líneas 14–15 en el constructor de `BasePlusCommissionEmployee` invocan el constructor de `CommissionEmployee` (declarado en las líneas 14–24 de la Figura 11.4) a través de un inicializador de constructor. En la Sección 10.5, utilizamos un inicializador de constructor con la palabra clave `this` para llamar a un constructor sobrecargado en la misma clase. La línea 14 de la Figura 11.8 utiliza un inicializador de constructor con la palabra clave `base` para invocar el constructor de la clase base, pasando argumentos para inicializar las propiedades correspondientes de la clase base que fueron heredadas en el objeto de la clase derivada. Si el constructor de `BasePlusCommissionEmployee` no invocara explícitamente al constructor de `CommissionEmployee`, C# intentaría invocar implícitamente el constructor sin parámetros o predeterminado de la clase `CommissionEmployee`. `CommissionEmployee` no tiene tal constructor, por lo que el compilador emitiría un error.

### Método `Earnings` de `BasePlusCommissionEmployee`
Las líneas 41–42 de la Figura 11.8 declaran el método `Earnings` utilizando la palabra clave `override` para anular el método `Earnings` de `CommissionEmployee`, como lo hicimos con el método `ToString` en ejemplos anteriores. La línea 41 causa el primer error de compilación mostrado en la Figura 11.8, indicando que no podemos anular el método `Earnings` de la clase base porque no fue explícitamente "marcado virtual, abstracto o anulado". Las palabras clave virtual y abstracto indican que un método de la clase base puede ser anulado (*override*) en clases derivadas. El modificador `override` declara que un método de la clase derivada anula un método de la clase base virtual o abstracto. Este modificador también declara implícitamente el método de la clase derivada como virtual y permite que sea anulado en clases derivadas más abajo en la jerarquía de herencia. Agregar la palabra clave `virtual` a la declaración del método `Earnings` en la Figura 11.4, como en `public virtual decimal Earnings()`, elimina el primer error de compilación en la Figura 11.8.
El compilador genera errores adicionales para la línea 42 de la Figura 11.8, porque las variables de instancia `commissionRate` y `grossSales` de la clase base `CommissionEmployee` son privadas: los métodos de la clase derivada `BasePlusCommissionEmployee` no tienen permitido acceder a los miembros privados de la clase base. El compilador también emite errores en las líneas 49–50 en el método `ToString` por la misma razón. Los errores en `BasePlusCommissionEmployee` podrían haberse evitado usando las propiedades públicas heredadas de la clase `CommissionEmployee`. Por ejemplo, las líneas 42, 49 y 50 podrían haber invocado los accesores get de las propiedades `CommissionRate` y `GrossSale`s para acceder a las variables de instancia privadas `commissionRate` y `grossSales` de `CommissionEmployee`, respectivamente.