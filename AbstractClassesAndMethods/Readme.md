## Clases y Métodos Abstractos

Cuando pensamos en un tipo de clase, asumimos que las aplicaciones crearán objetos de ese tipo. Sin embargo, en algunos casos, es útil declarar clases para las cuales nunca pretendemos instanciar objetos. Estas clases se llaman clases abstractas (`abstract`). Debido a que solo se utilizan como clases base en jerarquías de herencia, nos referimos a ellas como clases base abstractas. Estas clases no pueden ser usadas para instanciar objetos porque, como verás pronto, las clases abstractas están incompletas: las clases derivadas deben definir las "piezas faltantes".

## Propósito de una Clase Abstracta

El propósito de una clase abstracta es principalmente proporcionar una clase base adecuada de la cual otras clases puedan heredar y, por lo tanto, compartir un diseño común. En la jerarquía de formas, por ejemplo, las clases derivadas heredan la noción de lo que significa ser una `Forma`, incluyendo atributos comunes como `Ubicación`, `Color` y `GrosorDelBorde` , y comportamientos como `Dibujar()`, `Mover()`, `CambiarDeTamaño()` y `CambiarDeColor()`. Las clases que se pueden utilizar para instanciar objetos se llaman clases concretas. Dichas clases proporcionan implementaciones de cada método que declaran (algunas de las implementaciones pueden ser heredadas). Por ejemplo, podríamos derivar clases concretas como `Círculo`, `Cuadrado` y `Triángulo` de la clase base abstracta `FormaBidimensional`. De manera similar, podríamos derivar clases concretas como `Esfera`, `Cubo` y `Tetraedro` de la clase base abstracta `FormaTridimensional`. Las clases abstractas son demasiado generales para crear objetos reales; especifican solo lo que es común entre las clases derivadas. Necesitamos ser más específicos antes de poder crear objetos. Por ejemplo, si envías el mensaje `Dibujar` a la clase abstracta `FormaBidimensional`, la clase sabe que las formas bidimensionales deberían ser dibujables, pero no sabe qué forma específica dibujar, por lo que no puede implementar un método de `Dibujar` real. Las clases concretas proporcionan los detalles necesarios para instanciar objetos.

### Código del Cliente que Utiliza Solo Tipos de Clases Base Abstractas

No todas las jerarquías de herencia contienen clases abstractas. Sin embargo, a menudo escribirás código del cliente que utiliza solo tipos de clases base abstractas para reducir las dependencias del código del cliente en una variedad de tipos de clases derivadas específicas. Por ejemplo, puedes escribir un método con un parámetro de un tipo de clase base abstracta. Cuando se llama, dicho método puede recibir un objeto de cualquier clase concreta que extienda directa o indirectamente la clase base abstracta especificada como el tipo del parámetro.

### Múltiples Niveles de Tipos de Clases Base Abstractas en una Jerarquía

Las clases abstractas a veces constituyen varios niveles de la jerarquía. Por ejemplo, la jerarquía de formas comienza con la clase abstracta `Shape`. En el siguiente nivel de la jerarquía hay dos clases abstractas más, `TwoDimensionalShape` y `ThreeDimensionalShape`. El siguiente nivel de la jerarquía declara clases concretas para `TwoDimensionalShapes` (Círculo, Cuadrado y Triángulo) y para `ThreeDimensionalShapes` (Esfera, Cubo y Tetraedro).

### Crear una Clase Abstracta

Se hace una clase abstracta al declararla con la palabra clave `abstract`. Normalmente, una clase abstracta contiene uno o más métodos abstractos. Un método abstracto es aquel que tiene la palabra clave `abstract` en su declaración, como en:

```csharp
public abstract void Dibujar(); // método abstracto
```

Los métodos abstractos *son implícitamente virtuales* y no proporcionan implementaciones. Una clase que contiene métodos abstractos debe ser declarada como una clase abstracta, incluso si contiene algunos **métodos concretos** (*no abstractos*). Cada clase derivada concreta de una clase base abstracta también debe proporcionar implementaciones concretas de los métodos abstractos de la clase base.

## Propiedades Abstractas

Las propiedades también pueden ser declaradas como abstractas o virtuales, y luego sobrescritas en clases derivadas con la palabra clave `override`, al igual que los métodos. Esto permite que una clase base abstracta especifique propiedades comunes de sus clases derivadas. Las declaraciones de propiedades abstractas tienen la forma:

```csharp
public abstract TipoPropiedad MiPropiedad { get; set; }  
```

Los puntos y comas después de las palabras clave `get` y `set` indican que no proporcionamos implementación para estos *accesores*. Una propiedad abstracta omite implementaciones para el *accesor* `get` y/o el *accesor* `set`. Las clases derivadas concretas deben proporcionar implementaciones para cada *accesor* declarado en la propiedad abstracta. Cuando se especifican tanto los *accesores* `get` como los `set`, cada clase derivada concreta debe implementar ambos. Si se omite un *accesor*, no se permite que la clase derivada implemente ese *accesor*. Hacerlo provoca un error de compilación.

## Constructores y Métodos Estáticos no Pueden ser Abstractos o Virtuales

Los constructores y los métodos estáticos *no pueden ser declarados* como **abstractos** o **virtuales**. Los constructores no se heredan, por lo que nunca se podría implementar un constructor de este tipo. De manera similar, *las clases derivadas no pueden sobrescribir métodos estáticos*, por lo que un método estático de este tipo nunca podría ser implementado.

## Declarando Variables de Tipos de Clase Base Abstractos

Aunque no podemos instanciar objetos de clases base abstractas, pronto verás que podemos usar clases base abstractas para declarar variables que pueden contener referencias a objetos de cualquier clase concreta derivada de esas clases abstractas. Las aplicaciones suelen utilizar estas variables para manipular objetos de clases derivadas de manera polimórfica. Además, puedes usar los nombres de las clases base abstractas para invocar métodos estáticos declarados en esas clases base abstractas.

## Polimorfismo y Controladores de Dispositivos

El polimorfismo es particularmente efectivo para implementar sistemas de software en capas. En los sistemas operativos, por ejemplo, cada tipo diferente de dispositivo físico podría operar de manera bastante diferente a los demás. Aun así, comandos comunes pueden leer o escribir datos desde y hacia los dispositivos. Para cada dispositivo, el sistema operativo utiliza un software llamado controlador de dispositivo para controlar toda la comunicación entre el sistema y el dispositivo. El mensaje de escritura enviado a un objeto controlador de dispositivo necesita ser interpretado específicamente en el contexto de ese controlador y cómo manipula un dispositivo específico. Sin embargo, la llamada de escritura en sí misma no es realmente diferente de la escritura en cualquier otro dispositivo del sistema: Colocar algún número de bytes desde la memoria en ese dispositivo. Un sistema operativo orientado a objetos podría usar una clase base abstracta para proporcionar una "interfaz" adecuada para todos los controladores de dispositivos. Luego, a través de la herencia de esa clase base abstracta, se forman clases derivadas que se comportan de manera similar. Los métodos del controlador de dispositivo se declaran como métodos abstractos en la clase base abstracta. Las implementaciones de estos métodos abstractos se proporcionan en las clases derivadas que corresponden a los tipos específicos de controladores de dispositivos. Siempre se están desarrollando nuevos dispositivos, a menudo mucho después de que se haya lanzado el sistema operativo. Cuando compras un nuevo dispositivo, viene con un controlador de dispositivo proporcionado por el fabricante del dispositivo. El dispositivo está inmediatamente operativo después de conectarlo a tu computadora e instalar el controlador de dispositivo. Este es otro ejemplo elegante de cómo el polimorfismo hace que los sistemas sean extensibles.

## Estudio de Caso: Sistema de Nómina Utilizando Polimorfismo

Esta sección reexamina la jerarquía de `CommissionEmployee-BasePlusCommissionEmployee` que exploramos en la Sección 11.4. Ahora utilizamos un método abstracto y el polimorfismo para realizar cálculos de nómina basados en el tipo de empleado. Creamos una jerarquía de empleados mejorada para resolver el siguiente problema:

*Una empresa paga a sus empleados de forma semanal. Los empleados son de cuatro tipos:
1. Los empleados asalariados reciben un salario fijo semanal independientemente de la cantidad de horas trabajadas.
2. Los empleados por hora reciben un pago por hora y reciben un pago de "tiempo y medio" por horas trabajadas en exceso de 40 horas.
3. Los empleados por comisión reciben un porcentaje de sus ventas.
4. Los empleados asalariados por comisión reciben un salario base más un porcentaje de sus ventas.*

*Para el período de pago actual, la empresa ha decidido recompensar a los empleados asalariados por comisión agregando un 10% a sus salarios base. La empresa desea implementar una aplicación que realice sus cálculos de nómina de manera polimórfica.*

Utilizamos la clase abstracta `Employee` para representar el concepto general de un empleado. Las clases que extienden `Employee` son `SalariedEmployee`, `CommissionEmployee` y `HourlyEmployee`. La clase `BasePlusCommissionEmployee`, que extiende `CommissionEmployee`, representa el último tipo de empleado. El diagrama de clases UML en la siguiente figura muestra la jerarquía de herencia para nuestra aplicación de nómina de empleados polimórfica. La clase base abstracta `Employee` está en *cursiva*, según la convención del UML.

La clase base abstracta `Employee` declara la **"interfaz"** de la jerarquía, es decir, el conjunto de miembros que una aplicación puede invocar en todos los objetos `Employee`. Utilizamos el término "interfaz" aquí en un sentido general para referirnos a las diversas formas en que las aplicaciones pueden comunicarse con objetos de cualquier clase derivada de `Employee`. Ten cuidado de no confundir la noción general de una "interfaz" con la noción formal de una interfaz de C#, que es el tema de la Sección 12.7. Cada empleado, independientemente de la forma en que se calculen sus ganancias, tiene un nombre, un apellido y un número de seguro social, por lo que esos datos aparecen en la clase base abstracta `Employee`.

![Employee hierarchy UML class diagram.](img/img1.png)

Las siguientes subsecciones implementan la jerarquía de clases de la clase `Employee`. La Sección 12.5.1 implementa la clase base abstracta `Employee`. Las Secciones 12.5.2–12.5.5 implementan cada una de las clases concretas. La Sección 12.5.6 implementa una aplicación de prueba que crea objetos de todas estas clases y procesa esos objetos de forma polimórfica.

## Creación de la Clase Base Abstracta `Employee`

La clase `Employee` proporciona los métodos `Earnings` y `ToString`, además de las propiedades de auto-implementación que manipulan los datos de `Employee`. Un método `Earnings` ciertamente se aplica de manera genérica a todos los empleados. Pero cada cálculo de ganancias depende de la clase del empleado. Por lo tanto, declaramos `Earnings` como abstracto en la clase base `Employee`, porque una implementación predeterminada no tiene sentido para ese método; no hay suficiente información para determinar qué cantidad debería devolver `Earnings`. Cada clase derivada anula `Earnings` con una implementación específica. Para calcular las ganancias de un empleado, la aplicación asigna una referencia al objeto del empleado a una variable de clase base `Employee`, luego invoca el método `Earnings` en esa variable. Mantenemos una `List` de variables de `Employee`, cada una de las cuales tiene una referencia a un objeto de `Employee` (por supuesto, no puede haber objetos de `Employee` porque `Employee` es una clase abstracta; sin embargo, debido a la herencia, todos los objetos de todas las clases derivadas de `Employee` aún pueden considerarse como objetos de `Employee`). La aplicación itera a través de la `List` y llama al método `Earnings` para cada objeto de `Employee`. Estas llamadas de método se procesan de forma polimórfica. Incluir `Earnings` como un método abstracto en `Employee` obliga a que cada clase concreta directamente derivada de `Employee` anule `Earnings` con un método que realice un cálculo de pago apropiado.

El método `ToString` en la clase `Employee` devuelve una cadena que contiene el nombre, apellido y número de seguro social del empleado. Cada clase derivada de `Employee` anula el método `ToString` para crear una representación de cadena de un objeto de esa clase que contiene el tipo de empleado (por ejemplo, "empleado asalariado:"), seguido del resto de la información del empleado.

El diagrama de la siguiente figura muestra cada una de las cinco clases en la jerarquía en el lado izquierdo y los métodos `Earnings` y `ToString` en la parte superior. Para cada clase, el diagrama muestra los resultados deseados de cada método. [Nota: No listamos las propiedades de la clase base `Employee` porque no se anulan en ninguna de las clases derivadas; cada una de estas propiedades se hereda y se utiliza "tal cual" por cada una de las clases derivadas].

![Polymorphic interface for the Employee hierarchy classes.](img/img2.png)

# Clase `Employee` (Cod: 12.4)

Consideremos la declaración de la clase `Employee`. La clase incluye propiedades de auto-implementación, de solo lectura, para el nombre, apellido y número de seguro social (líneas 5–7); un constructor que inicializa el nombre, apellido y número de seguro social (líneas 10–16); un método `ToString` expresado en cuerpo de expresión (líneas 19–20), que utiliza las propiedades para devolver la representación de cadena de un `Employee`; y el método abstracto `Earnings` (línea 23), que debe ser implementado por las clases derivadas concretas. El constructor de `Employee` **no valida** el* número de seguro social* en este ejemplo. Normalmente, dicha validación debería ser proporcionada.

¿Por qué declaramos `Earnings` como un método abstracto? Como se explicó anteriormente, simplemente no tiene sentido proporcionar una implementación de este método en la clase `Employee`. No podemos calcular las ganancias para un `Employee` *general*; primero debemos conocer el tipo de `Employee` específico para determinar el cálculo de ganancias apropiado. Al declarar este método como abstracto, indicamos que cada clase derivada concreta debe proporcionar una implementación adecuada de `Earnings` y que una aplicación *podrá usar variables de la clase base* `Employee` para invocar el método `Earnings` de manera polimórfica para cualquier tipo de `Employee`.

## Creando la Clase Derivada Concreta `SalariedEmployee` (Cod 12.5)

La clase `SalariedEmployee` (Cod. 12.5) extiende la clase `Employee` (línea 5) y anula `Earnings` (línea 37), lo que convierte a `SalariedEmployee` en una clase concreta. La clase incluye un constructor (líneas 10–15) que toma como argumentos un nombre, un apellido, un número de seguro social y un salario semanal; la propiedad `WeeklySalary` (líneas 18–34) para manipular la variable de instancia `weeklySalary`, incluido un accesor `set` que asegura asignar solo valores no negativos a `weeklySalary`; el método `Earnings` (línea 37) para calcular las ganancias de un **empleado asalariado**; y el método `ToString` (líneas 40–42), que devuelve una cadena que incluye el tipo de empleado, es decir, "empleado asalariado:", seguido de la información específica del empleado producida por el método `ToString` de la clase base `Employee` y la propiedad `WeeklySalary` de `SalariedEmployee`. El constructor de la clase `SalariedEmployee` pasa el nombre, apellido y número de seguro social al constructor de `Employee` (línea 11) a través de un inicializador de constructor para inicializar los datos de la clase base. El método `Earnings` anula el método `Earnings` abstracto de `Employee` para proporcionar una implementación concreta que devuelve el salario semanal de `SalariedEmployee`. Si no implementamos `Earnings`, la clase `SalariedEmployee` debe declararse abstracta; de lo contrario, se produce un error de compilación (y, por supuesto, queremos que `SalariedEmployee` sea una clase concreta).

El método `ToString` de `SalariedEmployee` (líneas 40–42) anula la versión de `Employee`. Si la clase `SalariedEmployee` no anulara `ToString`, heredaría la versión de `Employee`. En ese caso, el método `ToString` de `SalariedEmployee` simplemente devolvería el nombre completo del empleado y el número de seguro social, lo cual no representa adecuadamente a un empleado asalariado.

Para producir una representación completa en cadena de `SalariedEmployee`, el método `ToString` de la clase derivada devuelve "empleado asalariado: ", seguido de la información específica de la clase base `Employee` (es decir, nombre, apellido y número de seguro social) obtenida invocando el `ToString` de la clase base mediante la palabra clave `base` (línea 41) - esto es un buen ejemplo de *reutilización de código*. La representación en cadena también contiene el salario semanal del empleado, obtenido a través de la propiedad `WeeklySalary`.

## Creando la Clase Derivada Concreta `HourlyEmployee`

La clase `HourlyEmployee` (Cod. 12.6) también extiende la clase `Employee` (línea 5). La clase incluye un constructor (líneas 11–16) que toma como argumentos un nombre, un apellido, un número de seguro social, un salario por hora y el número de horas trabajadas. Las líneas 19–37 y 37–52 declaran las propiedades `Wage` y `Hours` para las variables de instancia `wage` y `hours` (líneas 7–8), respectivamente. El accessor `set` de `Wage` garantiza que el salario sea no negativo, y el accessor set de `Hours` asegura que las horas estén en el rango de 0 a 168 (el total de horas en una semana) inclusive.
La clase anula el método `Earnings` (líneas 59–69) para calcular las ganancias de un `HourlyEmployee` y el método `ToString` (líneas 72–74) para devolver la representación en cadena de un `HourlyEmployee`. El constructor de `HourlyEmployee` pasa el nombre, el apellido y el número de seguro social al constructor de la clase base `Employee` (línea 14) para inicializar los datos de la clase base. Además, el método `ToString` llama al método `ToString` de la clase base (línea 73) para obtener la representación en cadena de la información específica del `Employee` (es decir, nombre, apellido y número de seguro social).

## Creación de la Clase Derivada Concreta `CommissionEmployee`

La clase `CommissionEmployee` (Cod. 12.7) extiende la clase `Employee` (línea 5). La clase incluye un constructor (líneas 11-16) que toma un nombre, un apellido, un número de seguro social, un monto de ventas y una tasa de comisión; propiedades `GrossSales` y `CommissionRate` (líneas 18-33 y 36-51) para manipular las variables de instancia `grossSales` y `commissionRat`e, respectivamente; el método `Earnings` (línea 59) sobrescrito para calcular las ganancias de un `CommissionEmployee`; y el método `ToString` (líneas 57-60) sobrescrito, que devuelve la representación en cadena de un `CommissionEmployee`. El constructor también pasa el nombre, apellido y número de seguro social al constructor de `Employee` (línea 14) para inicializar los datos de `Employee`. El método `ToString` llama al método `ToString` de la clase base (línea 63) para obtener la representación en cadena de la información específica del empleado (es decir, nombre, apellido y número de seguro social).

## 12.5.6 Procesamiento Polimórfico, Operador `is` y Conversión Descendente

Para probar nuestra jerarquía de `Employee`, la aplicación del codigo 12.9 crea un objeto de cada una de las cuatro clases concretas `SalariedEmployee`, `HourlyEmployee`, `CommissionEmployee` y `BasePlusCommissionEmployee` (líneas 5-8). La aplicación manipula estos objetos, primero a través de variables de cada tipo de objeto (líneas 11-17), luego de manera polimórfica, utilizando una Lista (`List`) de variables de tipo `Employee` (líneas 20-41) —el método `ToString` de cada objeto se llama implícitamente por `WriteLine` cuando se imprime el objeto como una cadena. Mientras procesa los objetos de manera polimórfica, la aplicación aumenta el salario base de cada `BasePlusCommissionEmployee` en un 10% (esto, por supuesto, requiere determinar el tipo del objeto en tiempo de ejecución). Finalmente, las líneas 44-47 determinan y muestran de forma polimórfica el tipo de cada objeto en la Lista de `Employee`.

### Asignación de Objetos de Clase Derivada a Referencias de Clase Base

En la linea 20 se crea la lista `List<Employee>` llamada `employees` y la inicializan con los objetos `SalariedEmployee`, `HourlyEmployee`, `CommissionEmployee` y `BasePlusCommissionEmployee` creados en las líneas 5-8. Cada elemento de la lista es una variable `Employee`. Los objetos de clase derivada pueden ser asignados a cada elemento de `employees`, porque un `SalariedEmployee` *es un* `Employee`, un `HourlyEmployee` *es un* `Employee`, un `CommissionEmployee` es un *Employee* y un `BasePlusCommissionEmployee` *es un* `Employee`. Esto es permitido incluso aunque `Employee` sea una clase abstracta.

### Procesamiento Polimórfico de `Emplyees`

Las líneas 25-41 iteran a través de la lista de empleados (`employees`) y llaman a los métodos `ToString` y `Earnings` con la variable `Employee` llamada `currentEmployee`, a la cual se le asigna la *referencia* de un `Empleado` diferente durante cada iteración. La salida ilustra que los métodos apropiados para cada clase son invocados efectivamente. Todas las llamadas a los métodos virtuales `ToString` y `Earnings` se resuelven en tiempo de ejecución, basadas en el tipo del objeto al cual `currentEmployee` hace referencia.

Este proceso es conocido como **enlace dinámico** o **enlace tardío**. Por ejemplo, la línea 27 invoca implícitamente el método `ToString` del objeto al que `currentEmployee` hace referencia. Solo los métodos de la clase `Employee` pueden ser llamados a través de una variable `Employee`, y `Employee` incluye los métodos de la clase `object`, como `ToString`. Una referencia de clase base puede ser utilizada para invocar solo los métodos que fueron declarados originalmente en la clase base o más arriba en la jerarquía de clases.

### Aumentando los Salarios Base de los Empleados `BasePlusCommissionEmployee` en un 10%

Realizamos un procesamiento especial en los objetos `BasePlusCommissionEmployee`; al encontrarlos, aumentamos su salario base en un 10%. Cuando procesamos objetos de manera polimórfica, generalmente no necesitamos preocuparnos por los detalles, pero para ajustar el salario base, sí debemos determinar el tipo específico de cada objeto `Employee` en tiempo de ejecución. La línea 30 utiliza el operador `is` para determinar si el tipo de un objeto `Emplyee` en particular es `BasePlusCommissionEmployee`. La condición en la línea 30 es verdadera solo si el objeto al que hace referencia `currentEmployee` *es un* `BasePlusCommissionEmployee`. Esto también sería cierto para cualquier objeto de una clase derivada de `BasePlusCommissionEmployee` (si los hubiera), porque un objeto de cualquier clase derivada de `BasePlusCommissionEmployee` *es un* `BasePlusCommissionEmployee`.

La línea 34 realiza una conversión descendente (*downcast*) de `currentEmployee` del tipo `Employee` al tipo `BasePlusCommissionEmployee` y asigna el resultado a la variable de tipo `BasePlusCommissionEmployee` llamada `employee`. Esto se conoce como una conversión descendente, porque la conversión es a un tipo más bajo en la jerarquía de clases. Esta conversión descendente solo está permitida si el objeto al que hace referencia `currentEmployee` tiene una relación de *"es un"* con `BasePlusCommissionEmployee`; la condición en la línea 30 asegura que este sea el caso. ¿Por qué querríamos realizar una conversión descendente de este tipo? Una referencia de clase base solo puede usarse para invocar los métodos declarados en la clase base; intentar invocar un método exclusivo de la clase derivada a través de una referencia de clase base resulta en un error de compilación. Si una aplicación necesita realizar una operación específica de una clase derivada en un objeto de esa clase referenciado por una variable de clase base, la aplicación primero debe convertir la referencia de clase base en una referencia de clase derivada. Por lo tanto, esta conversión es necesaria en este programa para que podamos usar la propiedad `BaseSalary` de la clase derivada `BasePlusCommissionEmployee` en el `currentEmployee`.

Cuando se realiza una conversión descendente (*downcasting*) de un objeto, se produce una `InvalidCastException` (del espacio de nombres `System`) si en tiempo de ejecución el objeto no tiene una relación *"es un"* con el tipo especificado en el operador de conversión. Un objeto solo puede ser convertido a su propio tipo o al tipo de una de sus clases base. Puede evitar una posible `InvalidCastException` utilizando el operador `as` para realizar una conversión descendente en lugar de un operador de conversión. Por ejemplo, en la declaración:

```csharp
var employee = currentEmployee as BasePlusCommissionEmployee;
```

se le asigna a la variable `employee` una referencia a un objeto que es un `BasePlusCommissionEmployee`, o el valor `null` si `currentEmployee` no es un `BasePlusCommissionEmployee`. Luego, puede comparar `employee` con `null` para determinar si la conversión fue exitosa.
Si la expresión `is` en la línea 30 es verdadera, la instrucción `if` (líneas 30-39) realiza el procesamiento especial requerido para el objeto `BasePlusCommissionEmployee`. Utilizando la variable `BasePlusCommissionEmployee` llamada `employee`, la línea 36 accede a la propiedad `BaseSalary` exclusiva de la clase derivada para recuperar y actualizar el salario base del empleado con el aumento del 10%.
La línea 40 invoca el método `Earnings` en `currentEmployee`, que llama al método `Earnings` del objeto de clase derivada apropiada de manera polimórfica. Obtener las ganancias del `SalariedEmployee`, `HourlyEmployee` y `CommissionEmployee` de manera polimórfica en la línea 40 produce el mismo resultado que obtener las ganancias de estos empleados individualmente en las líneas 12, 13 y 15. Sin embargo, la cantidad de ganancias obtenida para el `BasePlusCommissionEmployee` en las líneas 40 es mayor que la obtenida en la línea 17, debido al aumento del 10% en su salario base.

### Cada objeto conoce su propio tipo

Las líneas 59–63 muestran el tipo de cada empleado como una cadena de caracteres. Cada objeto conoce su propio tipo y puede acceder a esta información a través del método `GetType`, el cual todas las clases heredan de la clase `object`. Este método devuelve un objeto de la clase `Type` (del espacio de nombres `System`), el cual contiene información sobre el tipo del objeto, incluyendo el nombre de su clase, los nombres de sus métodos y el nombre de su clase base. La línea 46 invoca el método `GetType` en el objeto para obtener su clase en tiempo de ejecución (es decir, un objeto `Type` que representa el tipo del objeto). Luego, implícitamente se invoca el método `ToString` en el objeto devuelto por `GetType`. El método `ToString` de la clase `Type` devuelve el nombre de la clase.

## Evitando Errores de Compilación con el **Downcasting**

En el ejemplo anterior, evitamos errores de compilación al realizar un *downcasting* de una variable `Employee` a una variable `BasePlusCommissionEmployee` en la línea 34, donde el tipo `BasePlusCommissionEmployee` se infiere de la operación de conversión. Si eliminamos el operador de conversión y tratamos de asignar la variable `Employee` directamente a una variable `BasePlusCommissionEmployee` llamada `employee` (con su tipo declarado explícitamente, en lugar de usar var), recibiríamos un error de compilación "No se puede convertir implícitamente el tipo". Este error indica que el intento de asignar la referencia del objeto de la clase base `currentEmployee` a la variable de la clase derivada `employee` no está permitido sin un operador de conversión apropiado. El compilador evita esta asignación porque un `CommissionEmployee` no es un `BasePlusCommissionEmployee`, nuevamente, la relación es-una se aplica solo entre la clase derivada y sus clases base, no al revés.
De manera similar, si las líneas 36 y 38 utilizan la variable de la clase base `currentEmployee` en lugar de la variable de la clase derivada `employee` al acceder a la propiedad exclusiva de la clase derivada `BaseSalary`, recibiríamos un error de compilación "'`Employee`' no contiene una definición para '`BaseSalary`'" en cada una de estas líneas. No se permite intentar invocar métodos o propiedades exclusivos de la clase derivada en una referencia de la clase base. Aunque las líneas 36 y 38 se ejecutan solo si la línea 30 devuelve true para indicar que `currentEmployee` se refiere a un objeto `BasePlusCommissionEmployee`, no podemos intentar usar la propiedad `BaseSalary` de la clase derivada `BasePlusCommissionEmployee` con la referencia de la clase base `Employee` `currentEmployee`. El compilador generaría errores en las líneas 36 y 38, porque `BaseSalary` no es un miembro de la clase base y no se puede usar con una variable de la clase base. Aunque el método real que se llama depende del tipo del objeto en tiempo de ejecución, una variable solo puede usarse para invocar aquellos métodos que son miembros del tipo de esa variable, lo cual verifica el compilador. Usando una variable de la clase base `Employee`, solo podemos invocar métodos y propiedades que se encuentran en la clase `Employee`: los métodos `Earnings` y `ToString`, y las propiedades `FirstName`, `LastName` y `SocialSecurityNumber`, y métodos heredados de la clase `object`.

## Resumen de las Asignaciones Permitidas Entre Variables de Clase Base y Clase Derivada

Ahora que has visto una aplicación completa que procesa diversos objetos de clases derivadas de manera polimórfica, resumimos lo que puedes y no puedes hacer con objetos y variables de clase base y clase derivada. Aunque un objeto de clase derivada también es un objeto de clase base, los dos son diferentes. Como se discutió anteriormente, los objetos de clase derivada pueden tratarse como si fueran objetos de clase base. Sin embargo, la clase derivada puede tener miembros adicionales exclusivos de la clase derivada. Por esta razón, asignar una referencia de clase base a una variable de clase derivada no está permitido sin una conversión explícita; tal asignación dejaría los miembros de la clase derivada sin definir para un objeto de clase base.

Hemos discutido cuatro formas de asignar referencias de clase base y clase derivada a variables de tipos de clase base y clase derivada:

1. Asignar una referencia de clase base a una variable de clase base es directo.
2. Asignar una referencia de clase derivada a una variable de clase derivada es directo.
3. Asignar una referencia de clase derivada a una variable de clase base es seguro, porque el objeto de clase derivada es un objeto de su clase base. Sin embargo, esta referencia solo puede usarse para referirse a miembros de la clase base. Si este código se refiere a miembros exclusivos de la clase derivada a través de la variable de clase base, el compilador reporta errores.
4. Intentar asignar una referencia de clase base a una variable de clase derivada es un error de compilación. Para evitar este error, la referencia de clase base debe ser convertida explícitamente a un tipo de clase derivada o debe ser convertida usando el operador as. En tiempo de ejecución, si el objeto al que hace referencia la referencia no es un objeto de clase derivada, ocurrirá una excepción (a menos que uses el operador as, en cuyo caso deberás verificar el resultado de la expresión para null). El operador is puede ser usado para asegurar que tal conversión se realice solo si el objeto es un objeto de clase derivada.
