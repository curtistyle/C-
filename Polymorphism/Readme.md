## Introducción

Continuamos nuestro estudio de la programación orientada a objetos explicando y demostrando el polimorfismo con jerarquías de herencia. El polimorfismo nos permite programar en lo general en lugar de programar en lo específico. En particular, el polimorfismo nos permite escribir aplicaciones que procesan objetos que comparten la misma clase base en una jerarquía de clases como si fueran todos objetos de la clase base.

Consideremos un ejemplo de polimorfismo. Supongamos que creamos una aplicación que simula el movimiento de varios tipos de animales para un estudio biológico. Las clases `Fish`, `Frog` y `Bird` representan los tipos de animales bajo investigación. Imaginemos que cada clase extiende la clase base `Animal`, que contiene un método `Move` y mantiene la ubicación actual del animal como coordenadas x-y-z. Cada clase derivada implementa el método `Move` de manera diferente. Nuestra aplicación mantiene una colección de referencias a objetos de las diversas clases derivadas de `Animal`. Para simular los movimientos de un animal, la aplicación envía a cada objeto el mismo mensaje una vez por segundo, es decir, `Move`. Cada tipo específico de `Animal` responde a un mensaje `Move` de manera única: un `Fish` podría nadar tres pies, una `Frog` podría saltar cinco pies y un `Bird` podría volar 10 pies.

La aplicación emite el mensaje `Move` a cada objeto animal de forma genérica, pero cada objeto modifica sus coordenadas x-y-z de manera apropiada para su tipo específico de movimiento. Confiar en que cada objeto "haga lo correcto" en respuesta a la misma llamada de método es el concepto clave del polimorfismo. El *mismo mensaje* (en este caso, `Move`) enviado a una variedad de objetos tiene muchas formas de resultados, de ahí el término polimorfismo.


## Los sistemas son fáciles de extender
Con el polimorfismo, podemos diseñar e implementar sistemas que son fácilmente extensibles: nuevas clases pueden ser agregadas con poca o ninguna modificación a las partes polimórficas de la aplicación, siempre y cuando las nuevas clases formen parte de la jerarquía de herencia que la aplicación procesa de manera genérica. Las únicas partes de una aplicación que deben ser alteradas para acomodar nuevas clases son aquellas que requieren conocimiento directo de las nuevas clases que agregas a la jerarquía. Por ejemplo, si extendemos la clase `Animal` para crear la clase `Tortuga` (que podría responder a un mensaje de Movimiento arrastrándose una pulgada), solo necesitamos escribir la clase `Tortuga` y la parte de la simulación que instancia un objeto `Tortuga`. Las partes de la simulación que procesan cada `Animal` de manera genérica pueden permanecer iguales.

## Jerarquía de Herencia de Empleados Polimórficos
A continuación, presentamos un estudio de caso que revisita la jerarquía de `Employee`. Desarrollamos una aplicación de nómina simple que calcula de manera polimórfica el pago semanal de varios tipos diferentes de empleados utilizando el método de `Earnings` de cada empleado. Aunque las ganancias de cada tipo de empleado se calculan de una manera específica, el polimorfismo nos permite procesar a los empleados *"en general"*. En el estudio de caso, ampliamos la jerarquía para incluir dos nuevas clases: SalariedEmployee (para personas que reciben un salario semanal fijo) y `HourlyEmployee` (para personas que reciben un salario por hora y "tiempo y medio" por horas extras). Declaramos un conjunto común de funcionalidades para todas las clases en la jerarquía actualizada en una clase base `Empleado` de la cual las clases `SalariedEmployee`, `HourlyEmployee` y `CommissionEmployee` heredan directamente y la clase `BasePlusCommissionEmployee` hereda indirectamente. Como pronto verás, cuando invocamos el método de `Earnings` de cada empleado a través de una referencia de clase base `Employee`, se realiza el cálculo correcto de ganancias debido a las capacidades polimórficas de C#.

## Determinar el Tipo de un Objeto en Tiempo de Ejecución

En ocasiones, al realizar un procesamiento polimórfico, necesitamos programar *"de manera específica"*. Nuestro estudio de caso de Empleados demuestra que una aplicación puede determinar el tipo de un objeto en tiempo de ejecución y actuar en consecuencia. En el estudio de caso, utilizamos estas capacidades para determinar si un objeto de empleado en particular es un `BasePlusCommissionEmployee`. Si es así, aumentamos el salario base de ese empleado en un 10%.

## Interfaces

Una interfaz describe un conjunto de métodos y propiedades que pueden ser llamados en un objeto, pero no proporciona implementaciones concretas para ellos. Puedes declarar clases que implementen (es decir, proporcionen implementaciones concretas para los métodos y propiedades de) una o más interfaces. Cada miembro de la interfaz debe ser definido para todas las clases que implementan la interfaz. Una vez que una clase implementa una interfaz, todos los objetos de esa clase tienen una relación de "es un" con el tipo de interfaz, y todos los objetos de la clase están garantizados de proporcionar la funcionalidad descrita por la interfaz. Esto también es válido para todas las clases derivadas de esa clase.

Las interfaces son particularmente útiles para asignar funcionalidades comunes a clases posiblemente no relacionadas. Esto permite que los objetos de clases no relacionadas sean procesados polimórficamente: los objetos de clases que implementan la misma interfaz pueden responder a las mismas llamadas de método. Para demostrar la creación y el uso de interfaces, modificamos nuestra aplicación de nómina para crear una aplicación general de cuentas por pagar que pueda calcular los pagos adeudados por las ganancias de los empleados de la empresa y los montos de facturas a facturar por bienes comprados. Como verás, las interfaces habilitan capacidades polimórficas similares a las habilitadas por la herencia.

## Ejemplos de Polimorfismo

Consideremos varios ejemplos adicionales de polimorfismo.

### Jerarquía de Herencia de Cuadriláteros
Si la clase `Rectángulo` se deriva de la clase `Cuadrilátero` (una figura de cuatro lados), entonces un `Rectángulo` es una versión más específica de un `Cuadrilátero`. Cualquier operación (por ejemplo, calcular el perímetro o el área) que se pueda realizar en un objeto `Cuadrilátero` también se puede realizar en un objeto `Rectángulo`. Estas operaciones también se pueden realizar en otros `Cuadriláteros`, como `Cuadrados`, `Paralelogramos` y `Trapecios`. El polimorfismo ocurre cuando una aplicación invoca un método a través de una variable de clase base; en tiempo de ejecución, se llama a la versión del método de la clase derivada correcta, según el tipo del objeto referenciado. 

## Jerarquía de Herencia de Objetos Espaciales de Videojuegos

Como otro ejemplo, supongamos que diseñamos un videojuego que manipula objetos de muchos tipos diferentes, incluidos objetos de las clases `Martian`, `Venusian`, `Plutonian`, `SpaceShip` y `LaserBeam`. Imagina que cada clase hereda de la clase base común `SpaceObject`, que contiene el método `Draw`. Cada clase derivada implementa este método. Una aplicación de gestión de pantalla mantiene una colección (por ejemplo, un array de `SpaceObject`) de referencias a objetos de las diversas clases. Para refrescar la pantalla, el gestor de pantalla envía periódicamente a cada objeto el mismo mensaje, es decir, `Draw`. Sin embargo, cada objeto responde de manera única. Por ejemplo, un objeto `Martian` podría dibujarse a sí mismo en rojo con el número apropiado de antenas. Una `SpaceShip` podría dibujarse a sí misma como un platillo volador plateado brillante. Un `LaserBeam` podría dibujarse a sí mismo como un haz rojo brillante a través de la pantalla. Nuevamente, el mismo mensaje (en este caso, `Draw`) enviado a una variedad de objetos tiene muchas formas de resultados.
Un gestor de pantalla podría usar el polimorfismo para facilitar la adición de nuevas clases a un sistema con modificaciones mínimas en el código del sistema. Supongamos que queremos agregar objetos `Mercurian` a nuestro videojuego. Para hacerlo, debemos construir una clase `Mercurian` que extienda `SpaceObject` y proporcione su propia implementación del método `Draw`. Cuando los objetos de la clase `Mercurian` aparecen en la colección de `SpaceObject`, el código del gestor de pantalla invoca el método `Draw`, exactamente como lo hace para cualquier otro objeto en la colección, independientemente de su tipo, por lo que los nuevos objetos `Mercurian` simplemente "se integran" sin ninguna modificación del código del gestor de pantalla por parte del programador. Así, sin modificar el sistema (excepto para construir nuevas clases y modificar el código que crea nuevos objetos), puedes usar el polimorfismo para incluir tipos adicionales que quizás no se hayan previsto cuando se creó el sistema.

## Demostración del Comportamiento Polimórfico

En la seccion anterior creó una jerarquía de clases de empleados por comisión, en la que la clase `BasePlusCommissionEmployee` heredaba de la clase `CommissionEmployee`. Los ejemplos en esa sección manipulaban objetos `CommissionEmployee` y `BasePlusCommissionEmployee` utilizando referencias para invocar sus métodos. Apuntábamos referencias de clase base a objetos de clase base y referencias de clase derivada a objetos de clase derivada. Estas asignaciones son naturales y directas: las referencias de clase base están destinadas a referirse a objetos de clase base, y las referencias de clase derivada están destinadas a referirse a objetos de clase derivada. Sin embargo, otras asignaciones son posibles.

El siguiente ejemplo apunta una referencia de clase base a un objeto de clase derivada, luego muestra cómo invocar un método en un objeto de clase derivada a través de una referencia de clase base invoca la funcionalidad de la clase derivada: el tipo del objeto referenciado real, no el tipo de la referencia, determina qué método se llama. Esto demuestra el concepto clave de que un objeto de clase derivada puede tratarse como un objeto de su clase base, lo que permite varias manipulaciones interesantes.

Una aplicación puede crear una colección de referencias de clase base que se refieran a objetos de muchos tipos de clase derivada, porque cada objeto de clase derivada es un objeto de su clase base. Por ejemplo, podemos asignar la referencia de un objeto `BasePlusCommissionEmployee` a una variable de clase base `CommissionEmployee` porque un `BasePlusCommissionEmployee` es un `CommissionEmployee`, por lo que podemos tratar un `BasePlusCommissionEmployee` como un `CommissionEmployee`.

Un objeto de clase base no es un objeto de ninguna de sus clases derivadas. Por ejemplo, no podemos asignar directamente la referencia de un objeto `CommissionEmployee` a una variable de clase derivada `BasePlusCommissionEmployee`, porque un `CommissionEmployee` no es un `BasePlusCommissionEmployee`: un `CommissionEmployee` no tiene, por ejemplo, una variable de instancia `baseSalary` ni una propiedad `BaseSalary`. El compilador permite la asignación de una referencia de clase base a una variable de clase derivada si convertimos explícitamente la referencia de clase base al tipo de clase derivada.

El codigo 12.1 demuestra tres formas de usar variables de clase base y clase derivada para almacenar referencias a objetos de clase base y clase derivada. Las dos primeras son directas, como en la Sección 11.4: asignamos una referencia de clase base a una variable de clase base y asignamos una referencia de clase derivada a una variable de clase derivada. Luego, demostramos la relación entre las clases derivadas y las clases base (es decir, la relación es-un) al asignar una referencia de clase derivada a una variable de clase base. [Nota: Esta aplicación utiliza las clases `CommissionEmployee` y `BasePlusCommissionEmployee` de las Figuras 11.10 y 11.11, respectivamente.]

En el codigo 12.1 , las líneas 11–12 crean un nuevo objeto `CommissionEmployee` y asignan su referencia a una variable `CommissionEmployee`, y las líneas 15–16 crean un nuevo objeto `BasePlusCommissionEmployee` y asignan su referencia a una variable `BasePlusCommissionEmployee`.

Estas asignaciones son naturales; el propósito principal de una variable `CommissionEmployee` es contener una referencia a un objeto `CommissionEmployee`. Las líneas 23–24 utilizan la referencia `commissionEmployee` para invocar los métodos `ToString` y `Earnings`. Debido a que `commissionEmployee` se refiere a un objeto `CommissionEmployee`, se llaman a la versión de los métodos de la clase base `CommissionEmployee`. De manera similar, las líneas 31–33 utilizan la referencia `basePlusCommissionEmployee` para invocar los métodos `ToString` y `Earnings` en el objeto `BasePlusCommissionEmployee`. Esto llama a la versión de los métodos de la clase derivada `BasePlusCommissionEmployee`.

Luego, la línea 37 asigna la referencia al objeto de la clase derivada `basePlusCommissionEmployee` a una variable de la clase base `CommissionEmployee`, que las líneas 41–43 utilizan para invocar los métodos `ToString` y `Earnings`. Nota que la llamada `commissionEmployee2.ToString()` en la línea 41 realmente llama al método `ToString` de la clase derivada `BasePlusCommissionEmployee`.

El compilador permite este "cruce" porque un objeto de una clase derivada es un objeto de su clase base (pero no viceversa). Cuando el compilador encuentra una llamada de método virtual realizada a través de una variable, verifica el tipo de clase de la variable para determinar si se puede llamar al método. Si esa clase contiene la declaración de método adecuada (o hereda una), la llamada se compila. En tiempo de ejecución, el tipo de objeto al que se refiere la variable determina el método real a utilizar.

