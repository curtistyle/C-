## Delegados (`delegate`)

En la Sección anterior, introdujimos el concepto de un delegado, un objeto que contiene una referencia a un método. Puedes llamar a un método a través de una variable de tipo **delegado**, delegando así al método referenciado la responsabilidad de realizar una tarea. Los delegados también te permiten pasar métodos hacia y desde otros métodos. Introdujimos los delegados en el contexto de los manejadores de eventos de la interfaz gráfica de usuario (GUI), pero se utilizan en muchas áreas del marco de trabajo .NET. Por ejemplo, en el Capítulo 9, presentamos la sintaxis de consulta LINQ. El compilador convierte tales consultas LINQ en llamadas a métodos de extensión, muchos de los cuales tienen parámetros de delegado. La Figura 19.6 declara y utiliza un tipo de delegado. En la Sección 19.11, utilizaremos los delegados en el contexto de los métodos de extensión LINQ.

### Declaración de un tipo de delegado
En la línea 9 se define un tipo de delegado llamado `NumberPredicate`. Una variable de este tipo puede almacenar una referencia a cualquier método que tome un argumento `int` y devuelva un `bool`. Un tipo de delegado se declara precediendo al encabezado de un método con la palabra clave `delegate` (colocada después de cualquier especificador de acceso, como público o privado) y siguiendo el encabezado del método con un punto y coma.
Una declaración de tipo de delegado incluye únicamente el encabezado del método: el encabezado describe un conjunto de métodos con parámetros específicos y un tipo de retorno específico.

### 19.8.2 Declaración de una Variable de Delegado
En la línea 16 se declara `evenPredicate` como una variable de tipo `NumberPredicate` y se inicializa con una referencia al método `IsEven` con cuerpo de expresión (línea 60). Dado que la firma del método `IsEven` coincide con la firma del delegado `NumberPredicate`, `IsEven` puede ser referenciado por una variable de tipo `NumberPredicate`. La variable `evenPredicate` ahora puede ser utilizada como un alias para el método `IsEven`. Una variable `NumberPredicate` puede contener una referencia a cualquier método que reciba un entero y devuelva un booleano. Las líneas 19 utilizan la variable `evenPredicate` para llamar al método `IsEven` y luego mostrar el resultado. El método referenciado por el delegado se llama usando el nombre de la variable de delegado en lugar del nombre del método, como en `evenPredicate(4)`.

### 19.8.3 Parámetros de Delegado
El verdadero poder de los delegados radica en pasar referencias de métodos como argumentos a otros métodos, como hacemos en este ejemplo con el método `FilterArray` (líneas 41–57). El método toma como argumentos:
	• un array de enteros y
	• un `NumberPredicate` que hace referencia a un método utilizado para filtrar los elementos del array.
El método devuelve una lista `List<int>` que contiene solo los enteros que satisfacen la condición especificada por el `NumberPredicate`. `FilterArray` devuelve una `List` porque no sabemos de antemano cuántos elementos se incluirán en el resultado.
La instrucción `foreach` (líneas 47–54) llama al método referenciado por el delegado `NumberPredicate` (línea 50) una vez por cada elemento del array. Si la llamada al método devuelve `true`, el elemento se incluye en el resultado. El `NumberPredicate` garantiza devolver ya sea `true` o `false`, porque cualquier método referenciado por un `NumberPredicate` debe devolver un `bool`, como se especifica en la definición del tipo de delegado `NumberPredicate` (línea 9). La línea 22 pasa a `FilterArray` el array de `int`s (`numbers`) y el `NumberPredicate` que hace referencia al método `IsEven` (`evenPredicate`). `FilterArray` luego llama al delegado `NumberPredicate` en cada elemento del array. La línea 22 asigna la lista devuelta por `FilterArray` a la variable `evenNumbers` y la línea 25 llama al método `DisplayList` (líneas 69–81) para mostrar los resultados.

### 19.8.4 Pasando un Nombre de Método Directamente a un Parámetro de Delegado
La línea 28 llama al método `FilterArray` para seleccionar los números impares en el array. En este caso, pasamos el nombre del método `IsOdd` (definido en la línea 63) como segundo argumento de `FilterArray`, en lugar de crear una variable `NumberPredicate`. La línea 31 muestra los resultados mostrando solo los números impares. La línea 34 llama al método `FilterArray` para seleccionar los números mayores que 5 en el array, usando el método IsOver5 (definido en la línea 66) como segundo argumento de `FilterArray`. La línea 37 muestra los elementos que son mayores que 5.